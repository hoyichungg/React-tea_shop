"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.handleHashChange = handleHashChange;
exports.handleSuccess = handleSuccess;
exports.handleWarnings = handleWarnings;
exports.handleErrors = handleErrors;
exports.showPending = void 0;

function _react() {
  const data = _interopRequireDefault(require("react"));

  _react = function _react() {
    return data;
  };

  return data;
}

function ErrorOverlay() {
  const data = _interopRequireWildcard(require("react-error-overlay"));

  ErrorOverlay = function ErrorOverlay() {
    return data;
  };

  return data;
}

function _stripAnsi() {
  const data = _interopRequireDefault(require("strip-ansi"));

  _stripAnsi = function _stripAnsi() {
    return data;
  };

  return data;
}

var _formatWebpackMessages = _interopRequireDefault(require("./formatWebpackMessages"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// @ts-ignore
let hadRuntimeError = false;
ErrorOverlay().startReportingRuntimeErrors({
  onError: function onError() {
    hadRuntimeError = true;
  }
});
let isFirstCompilation = true;
let mostRecentCompilationHash = null;
let hasCompileErrors = false;

function handleHashChange(hash) {
  mostRecentCompilationHash = hash;
}

function handleSuccess() {
  const isHotUpdate = !isFirstCompilation;
  isFirstCompilation = false;
  hasCompileErrors = false;

  if (isHotUpdate) {
    tryApplyUpdates(() => {
      ErrorOverlay().dismissBuildError();
    });
  }
}

function handleWarnings(warnings) {
  var isHotUpdate = !isFirstCompilation;
  isFirstCompilation = false;
  hasCompileErrors = false;

  function printWarnings() {
    const formatted = (0, _formatWebpackMessages.default)({
      warnings,
      errors: []
    });
    formatted.warnings.forEach(warning => {
      console.warn((0, _stripAnsi().default)(warning));
    });
  }

  if (isHotUpdate) {
    tryApplyUpdates(() => {
      printWarnings();
      ErrorOverlay().dismissBuildError();
    });
  } else {
    printWarnings();
  }
}

function handleErrors(errors) {
  isFirstCompilation = false;
  hasCompileErrors = true;
  const formatted = (0, _formatWebpackMessages.default)({
    errors,
    warnings: []
  });
  ErrorOverlay().reportBuildError(formatted.errors[0]);
  formatted.errors.forEach(error => {
    console.error((0, _stripAnsi().default)(error));
  });
}

function isUpdateAvailable() {
  // @ts-ignore
  return mostRecentCompilationHash !== __webpack_hash__;
}

function tryApplyUpdates(onHotUpdateSuccess) {
  // @ts-ignore
  if (!module.hot) {
    window.location.reload();
    return;
  } // TODO: is update available?
  // @ts-ignore


  if (!isUpdateAvailable() || module.hot.status() !== 'idle') {
    return;
  }

  function handleApplyUpdates(err, updatedModules) {
    if (err || !updatedModules || hadRuntimeError) {
      window.location.reload();
      return;
    }

    onHotUpdateSuccess === null || onHotUpdateSuccess === void 0 ? void 0 : onHotUpdateSuccess();

    if (isUpdateAvailable()) {
      // While we were updating, there was a new update! Do it again.
      tryApplyUpdates();
    }
  } // @ts-ignore


  module.hot.check(true).then(function (updatedModules) {
    handleApplyUpdates(null, updatedModules);
  }, function (err) {
    handleApplyUpdates(err, null);
  });
}

const showPending = () => {
  const el = document.createElement('div');
  el.style.position = 'absolute';
  el.style.left = '0px';
  el.style.top = '0px';
  el.style.width = '100%';
  el.style.background = '#fff1b8';
  el.style.zIndex = '2147483647000000';
  el.style.color = '#613400';
  el.style.textAlign = 'center';
  el.style.fontSize = '18px';
  el.style.fontFamily = 'Consolas, Menlo, Courier, monospace';
  el.style.padding = '8px 0';
  el.style.boxShadow = '0px 4px 8px rgba(0, 0, 0, 0.1)';
  el.innerHTML = 'Disconnected from the devServer, trying to reconnect...';
  document.body.appendChild(el);
  return el;
};

exports.showPending = showPending;