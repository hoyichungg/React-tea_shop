"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getExportProps = getExportProps;

function _react() {
  const data = _interopRequireDefault(require("react"));

  _react = function _react() {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("@umijs/utils");

  _utils = function _utils() {
    return data;
  };

  return data;
}

var _parse = require("../utils/parse");

var _propertyResolver = require("./propertyResolver");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getExportProps(code) {
  const ast = (0, _parse.parse)(code);
  let props = {};

  _utils().traverse.default(ast, {
    Program: {
      enter(path) {
        const node = path.node;
        const defaultExport = findExportDefault(node);
        if (!defaultExport || !_utils().t.isIdentifier(defaultExport)) return;
        const name = defaultExport.name;
        props = findAssignmentExpressionProps({
          programNode: node,
          name
        });
      }

    }
  });

  return props;
}

function findExportDefault(programNode) {
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = programNode.body[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      const n = _step.value;

      if (_utils().t.isExportDefaultDeclaration(n)) {
        return n.declaration;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return null;
}

function findAssignmentExpressionProps(opts) {
  const props = {};
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = opts.programNode.body[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      const n = _step2.value;
      let node = n;

      if (_utils().t.isExpressionStatement(node)) {
        // @ts-ignore
        node = node.expression;
      }

      if (_utils().t.isAssignmentExpression(node) && _utils().t.isMemberExpression(node.left) && _utils().t.isIdentifier(node.left.object) && node.left.object.name === opts.name) {
        const resolver = _propertyResolver.RESOLVABLE_WHITELIST.find(resolver => resolver.is(_utils().t.isAssignmentExpression(node) && node.right));

        if (resolver) {
          props[node.left.property.name] = resolver.get(node.right);
        }
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  return props;
}